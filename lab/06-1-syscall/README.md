# 系统调用实验

## 题目

添加一个系统调用, 该系统调用接受两个参数：  
参数1：以整型数表示的自己学号的后3位  
参数2：flag，取值为0或1，若为0，该系统调用的返回值为参数1的个位。若为1。该系统调用的返回值为参数1的十位。

此外，加入内核互斥锁，使得两个进程在调用该系统调用时，能够做到互斥访问该系统调用。

## 解答

要完成这个任务，总共有三个任务要点：
1. 编写自己的系统调用，并将其添加到kernel中
2. 重新编译并引导内核
3. 实现自己的用户态测试程序

### 编写并添加系统调用

实验提供了预编译的linux kernel源码，内核版本为6.1.0，下述的文件操作均在源码根目录下实现。

#### 修改系统调用表

操作系统课设所使用的实验平台为amd64架构，因此，要添加系统调用需要修改`arch/x86/entry`下的系统调用表（kernel出于代码共享和历史等原因将系统调用表放在`x86`而非`x86_64`下），`entry`指处理中断和系统调用等相关的代码，`arch/x86/entry/syscalls/syscall_64.tbl`就是需要修改的系统调用表。

系统调用表的结构如下所示，在linux 6.1.0下，最后一个64位系统调用号为450号，添加451号系统调用：

|系统调用号|ABI（应用二进制接口）|系统调用名称|系统调用处理函数|
|---|---|---|---|
|0|common|read|sys_read|
|1|common|write|sys_write|
|...|...|...|...|
|451|common|**my_syscall**|**sys_my_syscall**|

注意这里的系统调用名称和处理函数名称，后续添加的内容要和这里相同。

#### 修改系统调用函数头文件

在修改了系统调用表后，要在头文件中添加对于的函数定义，系统调用头文件`include/linux/syscalls.h`

由题目要求，需要传入两个`int`类型参数，于是添加如下行：

```c
/* My system call */
asmlinkage long sys_my_syscall(int num, int flag);
```

`asmlinkage`是一个宏，通常用于指示编译器以特定的方式处理函数的参数传递和调用约定，确保系统调用函数可以正确地从用户空间获取参数。   
返回值为long，其长度可以足够保存传回的参数，同时long在不同架构上行为一致，因此将其定为long。
函数名`sys_my_syscall`，这里要和系统调用表中的相同。
传入两个参数，一个为学号的后3位，一个为表示符，按需设置。

#### 自定义系统调用实现

根据题目，在自定义系统调用中要实现内核互斥锁，实现并发访问时的互斥，在系统调用即内核态下实现互斥锁和在用户态下实现有较大的不同。

在内核态下，使用`DEFINE_MUTEX(mutex)`这个宏定义互斥锁，而在用户态下，通常使用POSIX线程库即pthread中的相关函数进行互斥操作。

在`kernel/`下添加`my_syscall.c`，注意这里的命名要和系统调用表中相同。

由于自定义系统调用有两个参数，因此调用`SYSCALL_DEFINE2()`，完整的参数定义如下`SYSCALL_DEFINE2(my_syscall, int, num, int, flag)`，这个宏的实现将变量与类型分离，便于内部进行检查。

使用`DEFINE_MUTEX(mutex)`定义了一个全局的互斥锁后，使用`mutex_trylock()`尝试加锁，成功加锁后进入关键区进行操作，完成操作后使用`mutex_unlock()`释放锁，退出关键区，最终返回获得的十位或者各位数字。

具体实现参考`my_syscall.c`

#### 修改Makefile文件

完成了系统调用的实现后，还需要修改Makefile文件，将自定义系统调用添加到原有系统调用当中，后续编译内核时需要通过该文件编译自定义系统调用。

在`kernel/Makefile`中添加如下行，完成Makefile文件的修改。

```makefile
# My system call
obj-y += my_syscall.o
```

### 重新编译并引导内核

完成了系统调用的相关实现后，要重新编译系统内核，见根目录`README.md`。

### 实现用户态测试程序

在用户态下希望直接使用自定义系统调用，需要包含`sys/syscall.h`这一头文件，并使用`syscall()`函数进行调用，函数第一个参数为系统调用号，后续为向系统调用传入的参数。

具体实现参考`test_syscall.c`，使用方法:`gcc test_syscall.c -o ts.out && ./ts.out <id> <number of processes>`